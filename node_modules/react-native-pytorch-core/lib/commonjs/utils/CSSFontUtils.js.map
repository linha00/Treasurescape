{"version":3,"sources":["CSSFontUtils.ts"],"names":["ParserStates","parseIdentifier","str","identifiers","replace","split","i","length","test","join","parse","input","state","VARIATION","buffer","result","fontFamily","c","charAt","BEFORE_FONT_FAMILY","index","indexOf","push","slice","FONT_FAMILY","identifier","AFTER_OBLIQUE","fontStyle","LINE_HEIGHT","fontSize","fontVariant","fontWeight","num","parseFloat","fontStretch","lineHeight"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @hidden\n */\n\ntype CSSFont = {\n  fontFamily: string[];\n  fontStyle?: string;\n  fontSize?: string;\n  fontVariant?: string;\n  fontWeight?: string;\n  fontStretch?: string;\n  lineHeight?: string;\n};\n\n/**\n * CSS font parser states\n */\nenum ParserStates {\n  VARIATION,\n  LINE_HEIGHT,\n  FONT_FAMILY,\n  BEFORE_FONT_FAMILY,\n  AFTER_OBLIQUE,\n}\n\n/**\n * Attempt to parse a string as an identifier. Return\n * a normalized identifier, or null when the string\n * contains an invalid identifier.\n *\n * @param str\n * @return\n */\nfunction parseIdentifier(str: string): string | null {\n  const identifiers: string[] = str\n    .replace(/^\\s+|\\s+$/, '')\n    .replace(/\\s+/g, ' ')\n    .split(' ');\n\n  for (let i = 0; i < identifiers.length; i += 1) {\n    if (\n      /^(?:-?\\d|--)/.test(identifiers[i]) ||\n      !/^(?:[_a-zA-Z0-9-]|[^\\0-\\237]|(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?|\\\\[^\\n\\r\\f0-9a-f]))+$/.test(\n        identifiers[i],\n      )\n    ) {\n      return null;\n    }\n  }\n  return identifiers.join(' ');\n}\n\n/**\n * Parses a string into a [[CSSFont]] or returns null if it fails.\n *\n * @param input CSS string as input.\n * @return The parsed [[CSSFont]] or null.\n */\nexport function parse(input: string): CSSFont | null {\n  let state = ParserStates.VARIATION;\n  let buffer = '';\n  let result: CSSFont = {\n    fontFamily: [],\n  };\n\n  for (let c, i = 0; (c = input.charAt(i)); i += 1) {\n    if (state === ParserStates.BEFORE_FONT_FAMILY && (c === '\"' || c === \"'\")) {\n      let index = i + 1;\n\n      // consume the entire string\n      do {\n        index = input.indexOf(c, index) + 1;\n        if (!index) {\n          // If a string is not closed by a ' or \" return null.\n          return null;\n        }\n      } while (input.charAt(index - 2) === '\\\\');\n\n      result.fontFamily.push(input.slice(i, index));\n\n      i = index - 1;\n      state = ParserStates.FONT_FAMILY;\n      buffer = '';\n    } else if (state === ParserStates.FONT_FAMILY && c === ',') {\n      state = ParserStates.BEFORE_FONT_FAMILY;\n      buffer = '';\n    } else if (state === ParserStates.BEFORE_FONT_FAMILY && c === ',') {\n      const identifier = parseIdentifier(buffer);\n\n      if (identifier) {\n        result.fontFamily.push(identifier);\n      }\n      buffer = '';\n    } else if (state === ParserStates.AFTER_OBLIQUE && c === ' ') {\n      if (/^(?:\\+|-)?(?:[0-9]*\\.)?[0-9]+(?:deg|grad|rad|turn)$/.test(buffer)) {\n        result.fontStyle += ' ' + buffer;\n        buffer = '';\n      } else {\n        // The 'oblique' token was not followed by an angle.\n        // Backtrack to allow the token to be parsed as VARIATION\n        i -= 1;\n      }\n      state = ParserStates.VARIATION;\n    } else if (state === ParserStates.VARIATION && (c === ' ' || c === '/')) {\n      if (\n        /^(?:(?:xx|x)-large|(?:xx|s)-small|small|large|medium)$/.test(buffer) ||\n        /^(?:larg|small)er$/.test(buffer) ||\n        /^(?:\\+|-)?(?:[0-9]*\\.)?[0-9]+(?:em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)$/.test(\n          buffer,\n        )\n      ) {\n        state =\n          c === '/'\n            ? ParserStates.LINE_HEIGHT\n            : ParserStates.BEFORE_FONT_FAMILY;\n        result.fontSize = buffer;\n      } else if (/^italic$/.test(buffer)) {\n        result.fontStyle = buffer;\n      } else if (/^oblique$/.test(buffer)) {\n        result.fontStyle = buffer;\n        state = ParserStates.AFTER_OBLIQUE;\n      } else if (/^small-caps$/.test(buffer)) {\n        result.fontVariant = buffer;\n      } else if (/^(?:bold(?:er)?|lighter)$/.test(buffer)) {\n        result.fontWeight = buffer;\n      } else if (\n        /^[+-]?(?:[0-9]*\\.)?[0-9]+(?:e[+-]?(?:0|[1-9][0-9]*))?$/.test(buffer)\n      ) {\n        const num = parseFloat(buffer);\n        if (num >= 1 && num <= 1000) {\n          result.fontWeight = buffer;\n        }\n      } else if (\n        /^(?:(?:ultra|extra|semi)-)?(?:condensed|expanded)$/.test(buffer)\n      ) {\n        result.fontStretch = buffer;\n      }\n      buffer = '';\n    } else if (state === ParserStates.LINE_HEIGHT && c === ' ') {\n      if (\n        /^(?:\\+|-)?([0-9]*\\.)?[0-9]+(?:em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)?$/.test(\n          buffer,\n        )\n      ) {\n        result.lineHeight = buffer;\n      }\n      state = ParserStates.BEFORE_FONT_FAMILY;\n      buffer = '';\n    } else {\n      buffer += c;\n    }\n  }\n\n  // This is for the case where a string was specified followed by\n  // an identifier, but without a separating comma.\n  if (state === ParserStates.FONT_FAMILY && !/^\\s*$/.test(buffer)) {\n    return null;\n  }\n\n  if (state === ParserStates.BEFORE_FONT_FAMILY) {\n    const identifier = parseIdentifier(buffer);\n\n    if (identifier) {\n      result.fontFamily.push(identifier);\n    }\n  }\n\n  if (result.fontSize && result.fontFamily.length) {\n    return result;\n  } else {\n    return null;\n  }\n}\n"]}